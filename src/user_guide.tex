 \documentclass[11pt,a4paper]{article}

\usepackage{pslatex}
\usepackage{inconsolata}
\usepackage[square,numbers]{natbib}
\usepackage[includehead,top=2.5cm,bottom=2.5cm,
            left=3cm,right=3cm]{geometry}
\usepackage{listings}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bm}
\usepackage{graphicx}

\usepackage{color}
\definecolor{bluish}{rgb}{0.20,0.29,0.46}
% *always \use this last*
\usepackage[colorlinks,breaklinks,pdftex,bookmarks=true,
            linkcolor=bluish,citecolor=bluish,urlcolor=bluish]{hyperref}

\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\usepackage{enumitem}
\setlist{topsep=0ex,itemsep=2pt,partopsep=0pt,parsep=0pt,leftmargin=7.5mm}

% Bold face for vectors
\renewcommand{\vec}[1]{\mathbf{#1}}

% Sublist style for drafting
\renewcommand\labelenumii{\theenumii.}
\renewcommand\theenumii{\arabic{enumii}}
\renewcommand\theenumiii{\arabic{enumiii}}

\begin{document}
\lstset{language=bash}

{\huge User Guide for Spowtd v0.6.0}\\[2ex]
{\large Alex Cobb}\\[0ex]

\renewcommand{\baselinestretch}{1.18}\normalsize

This is the user guide for Spowtd, which implements the scalar
parameterization of water table dynamics described in
\citet{Cobb_et_al_2017} and \citet{Cobb_and_Harvey_2019}.

\section{The steps of scalar parameterization}
Scalar parameterization involves these essential steps:
\begin{enumerate}
\item Load water level, precipitation and evapotranspiration data;
\item Identify dry intervals and storm intervals;
\item Match intervals of rising water levels to rainstorms;
\item Construct a master rising curve;
\item Construct a master recession curve;
\item Fit a preliminary specific yield function to the master rising
  curve;
\item Jointly fit a specific yield and a conductivity (equivalently,
  transmissivity) function to the master rising and recession curves.
\end{enumerate}

\section{The spowtd script}
The \texttt{spowtd} script provides a command-line interface to
perform calculations with Spowtd.

\subsection{Dependencies}
Running the script requires Python 3 and the Python packages
\href{https://matplotlib.org/}{Matplotlib},
\href{https://numpy.org/}{Numpy}, and
\href{https://pypi.org/project/pytz/}{Pytz}.

\subsection{Using the script}
The \texttt{spowtd} script has these subcommands (typically run in
this order):
\begin{itemize}
\item \texttt{spowtd load}: Load water level, precipitation and
  evapotranspiration data.
\item \texttt{spowtd classify}: Classify data into storm and
  interstorm intervals.
\item \texttt{spowtd set-zeta-grid}: Set up water level grid for
  master curves.
\item \texttt{spowtd recession}: Assemble recession curve.
\item \texttt{spowtd rise}: Assemble rise curve.
\item \texttt{spowtd plot}: Plot data.
\item \texttt{spowtd set-curvature}: Set site curvature.
\item \texttt{spowtd simulate}: Simulate data rise curve, recession
  curve, or rising and receding intervals.
\item \texttt{spowtd pestfiles}: Generate input files for calibration
  with PEST.
\end{itemize}

The first step is to load the precipitation, evapotranspiration and
water level data.  The input text files must be in an UTF-8-compatible
encoding (ASCII is fine).  The time zone is stored with the dataset
and will be used in plots (all times are stored internally as UNIX
timestamps).  For example, to load data into a new dataset file called
\texttt{ekolongouma.sqlite3}:
\begin{lstlisting}[frame=single]
spowtd load ekolongouma.sqlite3 \
  -vvv \
  --precipitation src/precipitation_Ekolongouma.txt \
  --evapotranspiration src/evapotranspiration_Ekolongouma.txt \
  --water-level src/waterlevel_Ekolongouma.txt \
  --timezone Africa/Lagos
\end{lstlisting}
The verbosity flags (\texttt{-vvv}) are not required; they cause the
script to report more on what is being done.

Next, classify the water level and precipitation time series into
storm and interstorm intervals based on thresholds for rainfall
intensity and rates of increase in water level.  For example, this
command classifies intervals with precipitation of at least 4~mm / h
as storms, and intervals in which the water level is increasing at a
rate of least 8~mm / h as storm response.
\begin{lstlisting}[frame=single]
spowtd classify ekolongouma.sqlite3 \
  -vvv \
  --storm-rain-threshold-mm-h 4.0 \
  --rising-jump-threshold-mm-h 8.0
\end{lstlisting}
(For details on how Spowtd matches storms with rises in water level,
see Appendix~\ref{a:storm_matching}.)

At this stage the classification can be plotted.  A basic interactive
plot showing the classified water level and precipitation time series
can be produced with:
\begin{lstlisting}[frame=single]
spowtd plot time-series ekolongouma.sqlite3
\end{lstlisting}
An additional panel showing evapotranspiration is plotted if the
\texttt{-e} or \texttt{--plot-evapotranspiration} flag is passed.  The
parts of the water level time series marked as interstorms are on a
light red background, and the parts of the water level time series
marked as storm response are on a light green background.  The parts
of the precipitation time series marked as storms are on a light blue
background.  You can pan in the plot with the right mouse button and
zoom with a left mouse button, or use the magnifying glass to zoom in.
You can revert to earlier zoom and pan values with the arrow buttons.

Adding \texttt{-f} or \texttt{--flags} highlights the parts of the
water level time series that have been classified as storm response
and interstorms, and the parts of the precipitation time series
\begin{lstlisting}[frame=single]
spowtd plot time-series ekolongouma.sqlite3  -f
\end{lstlisting}
The rising intervals are highlighted in blue, intervals with rising
intervals that could not be matched to rain storms are highlighted in
magenta, and rain storms are highlighted in red.

The next step is to establish a uniform grid for water levels.  This
grid is used when storm and interstorm intervals are assembled into
rising and recession curves.
\begin{lstlisting}[frame=single]
spowtd set-zeta-grid -vvv ekolongouma.sqlite3
\end{lstlisting}

The next two steps assemble the recession and rise curves:
\begin{lstlisting}[frame=single]
spowtd recession -vvv ekolongouma.sqlite3
\end{lstlisting}

\begin{lstlisting}[frame=single]
spowtd rise -vvv ekolongouma.sqlite3
\end{lstlisting}
If desired, the correlated errors produced by imprecision in recharge
depth measurement can be taken into account when assembling the rise
curve (see Appendix~\ref{b:rise_weighting}, ``Event weighting in rise
analysis'').  To do so, pass in a relative weight to assign to these
errors, vs.\ direct errors in water level measurement, via
\texttt{--recharge-error-weight}:
\begin{lstlisting}[frame=single]
spowtd rise -vvv ekolongouma.sqlite3 --recharge-error-weight=1e3
\end{lstlisting}
To examine the error covariance matrix used in the rise curve
assembly, append the \texttt{--dump-covariance} flag and the error
covariance matrix will be written to a file (default is standard
output) as JSON.

The recession and rise curves are now assembled, and can be plotted.
\begin{lstlisting}[frame=single]
spowtd plot recession ekolongouma.sqlite3
\end{lstlisting}

\begin{lstlisting}[frame=single]
spowtd plot rise ekolongouma.sqlite3
\end{lstlisting}
These plots can be interacted with in the same way: left mouse button
to pan, right mouse button to zoom, disk icon to save.

\section{Parameterization}
Parameters are provided to \texttt{spowtd} in
\href{https://yaml.org/}{YAML} format.

Currently two types of parameter sets are supported: (1) Cubic spline
for specific yield, piecewise linear for the logarithm of
conductivity; and (2) The PEATCLSM parameterization.

The spline parameterizations look like this:
\begin{lstlisting}[frame=single]
specific_yield:
  type: spline
  zeta_knots_mm:
    - -291.7
    - -183.1
    - -15.74
    - 10.65
    - 38.78
    - 168.3
  sy_knots:  # Specific yield, dimensionless
    - 0.1358
    - 0.1671
    - 0.2541
    - 0.2907
    - 0.2892
    - 0.6857
transmissivity:
  type: spline
  zeta_knots_mm:
    - -291.7
    - -5.167
    - 168.3
    - 1000
  K_knots_km_d:  # Conductivity, km/d
    - 5.356e-3
    - 1.002
    - 6577.0
    - 8.430e+3
  minimum_transmissivity_m2_d: 7.442  # Minimum transmissivity, m2/d
\end{lstlisting}
and the PEATCLSM parameterizations look like this:
\begin{lstlisting}[frame=single]
specific_yield:
  type: peatclsm
  sd: 0.162  # standard deviation of microtopographic distribution, m
  theta_s: 0.88  # saturated moisture content, m^3/m^3
  b: 7.4  # shape parameter, dimensionless
  psi_s: -0.024  # air entry pressure, m
transmissivity:
  type: peatclsm
  Ksmacz0: 7.3  # m/s
  alpha: 3  # dimensionless
  zeta_max_cm: 5.0
\end{lstlisting}
(the text following each parameter, after the \verb|#|, is a comment
and invisible to spowtd).

The specific yield and transmissivity curves can be plotted with
\begin{lstlisting}[frame=single]
  spowtd plot WHAT parameters.yml WATER_LEVEL_MIN_CM WATER_LEVEL_MAX_CM
\end{lstlisting}
where \texttt{WHAT} is one of \texttt{specific-yield},
\texttt{conductivity} or \texttt{transmissivity},
\texttt{parameters.yml} is a YAML file containing hydraulic
parameters, and the last two arguments specify the range of water
levels over which to plot the curve.

The plotting commands \texttt{plot rise}, \texttt{plot recession} and
\texttt{plot time-series} support a parameter \texttt{-p},
\texttt{--parameters}; if a YAML file containing hydraulic parameters
is passed to one of these commands, the corresponding plot (rising
curve, recession curve, rising and receding intervals) is simulated
using those parameters.

The simulated curves and corresponding data can be obtained as text
using \texttt{spowtd simulate WHAT data.sqlite3 parameters.yml} where
\texttt{WHAT} is \texttt{rise}, \texttt{recession}, or
\texttt{intervals}.  These commands write simulated data, water level
data, and / or residuals to an output file (standard output by
default) as delimited text.  For example,
\begin{lstlisting}[frame=single]
spowtd simulate rise ekolongouma.sqlite3 parameters.yml
\end{lstlisting}
reads data from \texttt{ekolongouma.sqlite3} and parameters from the
file \texttt{parameters.yml} and writes the assembled and simulated
rise curves to standard output.  The curves are simulated over the
range of water levels in the data, so plots from different SQLite
files may look different even if the parameters are identical.

To simulate (or plot) recession requires setting the large-scale
curvature of the site.  The command
\begin{lstlisting}[frame=single]
  spowtd set-curvature ekolongouma.sqlite3 1.0
\end{lstlisting}
sets the site curvature to $1~\text{m}/\text{km}/\text{km}$, whereafter
\begin{lstlisting}[frame=single]
  spowtd simulate recession ekolongouma.sqlite3 parameters.yml
\end{lstlisting}
simulates the water table recession.

\section{Calibration with PEST}
The simulation scripts make it possible to calibrate the specific
yield and transmissivity functions against rise and recession of the
water level using the \href{https://pesthomepage.org/}{PEST} software
package and tools for model-independent parameter estimation and
uncertainty analysis.  It should also be possible to calibrate using
\href{https://www.usgs.gov/software/pest-software-suite-parameter-estimation-uncertainty-analysis-management-optimization-and}{PEST++},
which is designed to have the same text-based interface, by following
a similar procedure.

PEST is a highly configurable set of tools.  One of its strengths is
that it is possible to start with a fairly simple approach and
incorporate more sophisticated functionality as it is needed.  As an
introduction, we illustrate calibration of specific yield parameters
against the rise curve.

For a calibration with PEST, you need to create five text files:
\begin{enumerate}
\item A PEST control file (\texttt{.pst}), which configures how PEST
  will perform the calibration (including identifying the other files
  used during calibration);
\item A parameter template file (\texttt{.tpl}), into which PEST will
  substitute parameter values in a format that can be read by Spowtd;
\item An output template file, or PEST ``instruction file''
  (\texttt{.ins}), which teaches PEST how to extract ``observations''
  from \texttt{spowtd simulate} output;
\item A vector of initial parameters (\texttt{.par}) to start the
  calibration; and
\item A script to execute the rise simulation.
\end{enumerate}

The first step is to create the PEST control file (\texttt{.pst})
following the PEST documentation \citep{Doherty_2010}.  For a PEATCLSM
parameterization, the control file will describe the four PEATCLSM
parameters for specific yield (\texttt{sd}, \texttt{theta\_s},
\texttt{b}, and \texttt{psi\_s}), each with their own parameter group.
The control file must also include an ``observation data'' section
with a single line giving mean dynamic storage for each water level in
the rise curve. The ``model command line'' section must provide the
command line needed to run the script to generate the rise curve.  The
script itself can be, for example, a bash script that calls
\texttt{spowtd simulate rise}.  Finally, the ``model input/output''
section specifies the path to the parameter template file, the path to
the the parameter file that PEST will create by substituting parameter
values into the template, the path to the instruction file
(\texttt{.ins}) that PEST uses to interpret the simulation output, and
the path to the output file created by a single run of the simulation
script.

The parameter template file (\texttt{.tpl}) and the parameter vector
file (\texttt{.par}) are created by replacing values in a Spowtd YAML
parameter file by placeholders, as described in the PEST
documentation.  In the case of calibration of PEATCLSM specific yield
parameters against a rise curve, the template file might look like this:
\begin{lstlisting}[frame=single]
ptf @
specific_yield:
  type: peatclsm
  sd: @sd                      @
  theta_s: @theta_s                 @
  b: @b                       @
  psi_s: @psi_s                   @
transmissivity:
  type: peatclsm
  Ksmacz0: 7.3  # m/s
  alpha: 3  # dimensionless
  zeta_max_cm: 5.0
\end{lstlisting}
and an initial parameter vector file might look like this:
\begin{lstlisting}[frame=single]
double point
          sd    0.162                      1.000000         0.000000
     theta_s    0.88                       1.000000         0.000000
           b    7.4                        1.000000         0.000000
       psi_s    -0.024                     1.000000         0.000000
\end{lstlisting}
In this example, the parameters \texttt{Ksmacz0} and \texttt{alpha}
are not included in the parameter vector file because only the rise
curve is being fitted.  The parameters of the transmissivity are not
free (they do not affect the rising curve fit), and therefore these
values are fixed in the template file and omitted from the parameter
vector file.

To verify the format of a template \texttt{rise\_pars.yml.tpl} and
initial parameters \texttt{rise\_init.par}, use the PEST
\texttt{tempchek} command:
\begin{lstlisting}[frame=single]
tempchek rise_pars.yml.tpl rise_pars.yml rise_init.par
\end{lstlisting}
This command should exit without errors and produce a valid parameter
file at \texttt{rise\_pars.yml}.

The parameter file can then be verified by running your script.  Your
script might, for example, contain the command
\begin{lstlisting}[frame=single]
spowtd simulate rise ekolongouma.sqlite3 rise_pars.yml -o rise_observations.yml --observations
\end{lstlisting}
which generates simulated dynamic storage values (without water levels
or measured dynamic storage values) in
\texttt{rise\_observations.yml}; in PEST, simulated output values are
referred to as ``observations.''

The resulting output file can then be checked against a PEST
instruction file (\texttt{.ins}) that you create for extracting
observation data, which might be called
\texttt{rise\_observations.ins}, using the PEST command
\texttt{inschek}:
\begin{lstlisting}[frame=single]
inschek rise_observations.ins rise_observations.yml
\end{lstlisting}

To then ensure that the correct initial parameters are used in the
calibration, substitute these into the control file using
\texttt{parrep}
\begin{lstlisting}[frame=single]
parrep rise_init.par rise_calibration.in.pst rise_calibration.pst
\end{lstlisting}

To then calibrate specific yield parameters against the rise curve
(alone) using the PEST control file \texttt{rise\_calibration}, call:
\begin{lstlisting}[frame=single]
pestchek rise_calibration &&
(pest rise_calibration.pst ;
 tempchek rise_pars.yml.tpl rise_opt.yml rise_calibration.par)
\end{lstlisting}
These commands check the PEST control file, perform the calibration,
and then substitute the calibrated parameter values from
\texttt{rise\_calibration.par} into \texttt{rise\_opt.yml}.

You can then examine the fit by plotting the rise curve with the
calibrated parameters:
\begin{lstlisting}[frame=single]
spowtd plot rise ekolongouma.sqlite3 --parameters rise_opt.yml
\end{lstlisting}

\subsection{Generating PEST input files with Spowtd}
As a convenience, Spowtd can generate input files for calibration with
PEST, either against the rise curve (\texttt{spowtd pestfiles rise})
or against both rise and recession curves (\texttt{spowtd pestfiles
  curves}).  The arguments to both subcommands are the same.  Taking
calibration against the rise curve as an example, a template file
can be created with
\begin{lstlisting}[frame=single]
spowtd pestfiles rise ekolongouma.sqlite3 parameters.yml tpl \\
  -o rise_parameters.yml.tpl
\end{lstlisting}
An instruction file can similarly be created with
\begin{lstlisting}[frame=single]
spowtd pestfiles rise ekolongouma.sqlite3 parameters.yml ins \\
  -o ekolongouma_rise_observations.ins
\end{lstlisting}
and a control file can be created with
\begin{lstlisting}[frame=single]
spowtd pestfiles rise ekolongouma.sqlite3 parameters.yml pst \\
  -o ekolongouma_rise_calibration.in.pst
\end{lstlisting}
The template and instruction files can be used as-is.  The generated
PEST control file will require substitution of valid starting
parameters and bounds, substitution of paths to input files and the
invocation for simualtion, adjustment of PEST control parameters, etc.

\bibliographystyle{unsrtnat}
\bibliography{user_guide.bib}

\appendix

\section{Matching of storms and water table rise}
\label{a:storm_matching}

For construction of rise curves, Spowtd matches intervals of rapidly
increasing water level (``rises'') to intervals of heavy rain
(``storms'') in such a way that each storm is matched to no more than
one rise and each rise is matched to no more than one storm.  This
matching is performed in two steps.  First, all storms and rises that
overlap in time are matched.  This first step may result in matching
from a single storm to multiple rises and vice versa.  This step is
followed by an arbitration step based on a variant of the Gale-Shapley
deferred acceptance algorithm for the stable matching problem: it
finds a set of matches between storms and rises that is stable in the
sense that, by switching a pair of matches between storms and rises,
one cannot improve the agreement in duration and start time for both
matches.

The arbitration step favors agreement in duration over agreement in
start time in matches by using a property of the Gale-Shapley
algorithm: it is guaranteed to yield the stable matching that is most
favorable for the proposing parties, and least favorable for the
parties accepting or rejecting proposals.  In matching between storms
and rises, each storm tries to match with the rise with the closest
duration; the rise is then able to reject that first match if another
storm with a closer start time proposes a match.  However, a storm
that is already matched with a rise with a more similar duration will
never propose to the rise with a closer start time.  Thus, arbitration
results in the stable matching that results in the best agreement in
duration between storms and rises.

Note that matching may still result in bad mismatches in storm and
rise duration depending on the thresholds set for identifying intense
rain (for storms) and rapid increase in water level (for rises).  If
differences between storm and rise duration are larger than you think
they should be, try adjusting one of these thresholds to get better
agreement.

\section{Event weighting in rise analysis}
\label{b:rise_weighting}

Assembly of recession curves benefits from the fact that both water
level and time usually can be measured fairly accurately.  In
contrast, rise events may be affected by large errors in measurement
of the recharge depth, either because of the difficulties in measuring
the precipitation that passes through the canopy and litter to reach
the water table, or because of spatial separation or scale differences
between where precipitation is measured and where the water table
response is evaluated.

In some cases the error in recharge depth measurement may be large
enough to cause problems in assembling a reasonable rise curve.
Because each rise event is represented as a straight line segment
between the water level and dynamic storage at the beginning and end
of the event, an error in the recharge depth is manifested as an error
in slope of this segment.  In the case of a range of water levels
where specific yield is approximately uniform so that the true slope
of the rise curve is approximately constant, this error in slope
causes an error in observed cumulative recharge that increases in
proportion to distance from the center of the rise event line segment
(Fig.~\ref{fig:rise_event_error}).  A single event spans multiple
water levels, and thus affects multiple equations.  In addition,
previous work on precipitation measurement indicates larger error for
higher precipitation, suggesting proportional errors.

Here we extend the unweighted approach to rise curve assembly in
\citet{Cobb_et_al_2017} and \citet{Cobb_and_Harvey_2019} to increase
its applicability to cases with larger errors in recharge measurement.
We first re-express the unweighted equations in the general form for a
linear estimation problem given by \citet{Paige_1979_computer}.  This
form includes explicit terms for the additive uncorrelated errors that
were minimized with that approach.  We then show how we modified the
approach to accommodate large, proportional errors in recharge
observations.

\begin{figure}[b!]
  \centerline{\includegraphics[scale=1]{build/doc/rise_event_error.pdf}}
  \caption{Model for error in recharge depth observations.}
  \label{fig:rise_event_error}
\end{figure}

Any linear estimation problem can be written in the following general
form \cite{Paige_1979_computer}:
\begin{equation}
  \label{eq:linear_estimation_problem}
  \begin{aligned}
    \min_{\vec{s},\vec{v}} \hspace{0.6em} & \vec{v}^\mathsf{T}\vec{v}\\
    \text{subject to} \hspace{0.6em} & \vec{y} = \vec{As} + \vec{Bv}
  \end{aligned}
\end{equation}
where $\vec{y} = \vec{As}$ is the overdetermined system of linear
equations to be solved for the unknowns $\vec{s}$, and $\vec{v}$ is a
vector of errors with zero mean and unit variance, which is then
appropriately scaled and distributed across equations by the matrix
$\vec{B}$.  When $\vec{B}$ is a square matrix with full rank, a
typical approach to solving the linear estimation problem
(\ref{eq:linear_estimation_problem}) is to assemble the error
covariance matrix $\bm\Omega = \vec{BB}^\mathsf{T}$, which will then be
symmetric and positive definite and therefore invertible, and solve
the generalized least-squares system
\begin{equation}
  \label{eq:gls}
  \vec{A}^\mathsf{T}\bm\Omega^{-1}\vec{A}\,\vec{s} = \vec{A}^\mathsf{T}\bm\Omega^{-1}\vec{y}
\end{equation}
for the unknowns $\vec{s}$.

We now show how the the unweighted rise curve assembly problem
\cite{Cobb_et_al_2017, Cobb_and_Harvey_2019} corresponds to the
general form of the linear estimation problem above
(\ref{eq:linear_estimation_problem}).  The unweighted rise curve
assembly problem involves finding a storage offset $s_j$ for each rise
event $j$ (Fig.~\ref{fig:rise_event_error}).  Each rise event $j$ and
water level $i$ (Table~\ref{tab:rise_notation}) yield a single
equation that can be written as
\begin{equation}
  \label{eq:single_unweighted_eqn}
  f_{ij} r_j + s_j - \frac{1}{|J_i|} \sum_{j'\in J_i} \left(r_{ij'} + s_{j'}\right) = e_k
\end{equation}
where $J_i$ is the set of rises crossing $\zeta_i$, $|J_i|$ is the
size (cardinality) of $J_i$ and $j'$ is a dummy index of summation.
The weighting coefficient $f_{ij}$ defined as
\begin{equation}
f_{ij} = \frac{\zeta_i - \overline{\zeta_j}}{\zeta_j^* - \zeta^o_j}
\end{equation}
where $\zeta^o_j$ is the water level at the beginning and $\zeta^*_j$ the water level at
the end of event $j$ (Fig.~\ref{fig:rise_event_error}).

In (\ref{eq:single_unweighted_eqn}), the first two terms on the left represent the
dynamic storage for event $j$ when it crosses water level $i$, while the summation term
in the round brackets computes the unweighted mean dynamic storage at water level $i$
over all events.  The error $e_k$ in the $k$th equation represents the deviation of the
dynamic storage for the $j$th event, when it crosses water level $i$, from the mean
dynamic storage across all events crossing that water level.  These deviations can arise
due to complexities that are ignored in the simple scalar model underlying rise curve
assembly, and from the approximation of the rise curve with straight line segments.  For
simplicity, in the unweighted implementation these factors were assumed to lead to
uncorrelated errors with a similar typical magnitude across all equations.

Note that the mean dynamic storage at $i$ (the term in the round
brackets in (\ref{eq:single_unweighted_eqn})) is not known a priori
because it itself depends on the offsets $\vec{s}$ for which we solve.
However, the mean is completely specified by any particular choice of
offsets $\vec{s}$; in fact it is a linear function of them.
Therefore, unweighted rise curve assembly \cite{Cobb_et_al_2017,
  Cobb_and_Harvey_2019} was able to incorporate the calculation of the
mean into the overdetermined system of linear equations that is then
solved by least squares.

The mean dynamic storage $s_J$ for rise event $J$ is set to 0 and
excluded from the unknowns to make the problem nonsingular; after
solving for the other dynamic storage values, a constant is subtracted
from all of these to define the dynamic storage as zero when the water
level is at the peat surface ($\zeta = 0$), as described in
\citet{Cobb_and_Harvey_2019}.

The entire system of $K$ unweighted equations can be written
\begin{equation}
  \label{eq:unweighted_equations}
  \vec{FD} \vec{r} + \vec{DTs} - \vec{M}_u(\vec{FDr} + \vec{DTs}) = \vec{e}
\end{equation}
where, in this unweighted case, the averaging operator $\vec{M}_u$ is
a simple arithmetic mean
\begin{equation}
  \label{eq:unweighted_mean}
  \vec{M}_u = \left[
    \begin{array}{ccc}
      \frac{1}{|J_{i_1}|}[j_1\in J_{i_1}] & \cdots & \frac{1}{|J_{i_1}|} [j_K\in J_{i_1}] \\
      \vdots & \ddots & \vdots \\
      \frac{1}{|J_{i_K}|}[j_1\in J_{i_K}] & \cdots & \frac{1}{|J_{i_K}|}[j_K\in J_{i_K}] \\
    \end{array}
  \right],
\end{equation}
which computes a mean across all events that cross each water level, and then
distributes each mean to all of the $K$ equations for that water level.  Here we use the
Iverson bracket $[P\,]$ to denote the indicator function that takes the value 1 if the
statement $P$ within the brackets is true and 0 otherwise, so that only the relevant
events are selected in each row.  The $K\times J$ equation-event incidence matrix
$\vec{D}$ records the event $j$ associated with each equation $j$ and has exactly one
nonzero value (equal to 1) in each row
\begin{equation}
  \label{eq:equation_event_incidence_matrix}
  \vec{D} = \left[
    \begin{array}{ccc}
      \left[j_1 = 1\right] & \cdots & \left[j_1 = J\right] \\ 
      \vdots & \ddots & \vdots \\
      \left[j_K = 1\right] & \cdots & \left[j_K = J\right]
    \end{array}
  \right].
\end{equation}
Operating on a $J$-vector of event-specific values, $\vec{D}$ distributes these to the
corresponding equations in a $K$-vector.  The truncation matrix $\vec{T}$
\begin{equation}
  \label{eq:truncation_matrix}
  \vec{T} = \left[
    \begin{array}{c}
      \vec{I}_{J-1}\\
      \vec{0}_{1,J-1}
    \end{array}
  \right]
\end{equation}
enforces the boundary condition $s_J = 0$ by transforming the $J-1$-vector of unknowns
$s$ into a $J$-vector with its last element set to $0$ ($\vec{T}\,\vec{s}$ is $\vec{s}$
with a zero concatenated to its end).

Rearranging (\ref{eq:unweighted_equations}) to put the unknown vector
with errors $\vec{e}$ on the right-hand-side, we have
\begin{equation}
  \label{eq:unweighted_equations_rearranged}
  \left(\vec{I} - \vec{M}_u\right)\vec{FD}\,\vec{r} = -\left(\vec{I} - \vec{M}_u\right)\vec{DT}\,\vec{s} + \vec{e}
\end{equation}
If we then define
$\vec{y}_u = \left(\vec{I} - \vec{M}_u\right)\vec{FD}\,\vec{r}$,
$\vec{A}_u = -\left(\vec{I} - \vec{M}_u\right)\vec{DT}$,
and $\vec{B}_u = \sigma_e\vec{I}$ where
$\sigma_e$ is the positive square root of the (uniform) variance of
the errors $\vec{e}$, so that $\vec{e} = \vec{B}_u\vec{v}$, we have
expressed the unweighted problem in the standard form
(\ref{eq:linear_estimation_problem}).  Because the covariance
$\bm\Omega_u = \vec{B}_u\vec{B}_u^\mathsf{T} = \sigma_e^2\vec{I}$ in
this unweighted case is just a positive multiple of the identity
matrix, so too is its inverse $\bm\Omega_u^{-1}$, and it cancels from
(\ref{eq:gls}) yielding the ordinary least-squares problem
\begin{equation}
  \label{eq:ols}
  \vec{A}_u^\mathsf{T}\vec{A}_u\,\vec{s} = \vec{A}_u^\mathsf{T}\,\vec{y}_u.
\end{equation}
Solving this ordinary least-squares problem (\ref{eq:ols}) for
$\vec{s}$ is equivalent to what was done in \citet{Cobb_et_al_2017}
and \citet{Cobb_and_Harvey_2019}; what we have outlined, then, is the
same procedure but with more general notation.

\begin{table}[b!]
  \centering
  \begin{tabular}{clp{9.8cm}}
    \emph{Symbol} & \emph{Dimensions} & \emph{Definition} \\
    \hline
    $\vec{e}$ & $K\times 1$ & Deviation of storage at water level $i$ for event $j$ from mean across all events at that water level \\
    $\vec{f}$ & $K\times 1$ & Weighting coefficient for error in cumulative
                              recharge for each water level $i$ and event $j$\\
    $i$ & & Index over discrete water levels $\zeta_i$\\
    $j$ & & Index over rise events\\
    $J_i$ & & Set of rise events crossing water level $i$\\
    $k$ & & Index over equations; enumerates $(i, j)$ pairs identifying water levels crossed by recharge events \\
    $\tilde{\vec{r}}$ & $J\times 1$ & Observed recharge for each event \\
    $\vec{r}$ & $J\times 1$ & True recharge depth for each event \\
    $\vec{s}$ & $(J - 1)\times 1$ & Dynamic storage offset for each event \\
    $\vec{D}$ & $K\times J$ & Equation-event incidence matrix \\
    $\vec{F}$ & $K\times K$ & $\text{diag}(\vec{f})$ \\
    $I$ & & Total number of water levels \\
    $\vec{I}$ & $K\times K$ & Identity matrix \\
    $J$ & & Total number of events \\
    $K$ & & Total number of equations $\sum_i |J_i|$ \\
    $\vec{M}$ & $K\times K$ & Weighted averaging operator \\
    $S_y$ & & Specific yield \\
    $\vec{T}$ & $J\times (J - 1)$ & Truncation matrix to set boundary condition $s_J = 0$ \\
    $\bm\alpha$ & $J\times 1$ & Multiplicative error in each recharge depth observation \\
    $\sigma_\alpha^2$ & & Variance of components of $\bm\alpha$ \\
    $\sigma_e^2$ & & Variance of components of $\vec{e}$ \\
    $\zeta$ & & Water level \\
    $\bm{\Omega}$ & $K\times K$ & Error covariance matrix \\
  \end{tabular}
  \caption{Notation for assembly of rise curves}
  \label{tab:rise_notation}
\end{table}

We now extend this analysis to the weighted case with large,
proportional errors in recharge observations.  Suppose recharge depth
observations $\tilde{\vec{r}}$ are affected by multiplicative
independent errors $\bm{\alpha}$, each identically distributed with
mean 1 and variance $\sigma_\alpha^2$.  In this case, for an event
$j$, instead of the true recharge $r_j$ we measure an observed
recharge $\tilde{r}_j = \alpha_j r_j$, so that the true recharge
$\vec{r}$ is related to observed recharge $\tilde{\vec{r}}$ by
\begin{equation}
  \label{eq:recharge_with_error}
  \vec{r} = \tilde{\vec{r}} - \text{diag}(\vec{r})\left(\bm\alpha - \vec{1}\right).
\end{equation}

In addition, because the variance of errors in recharge is no longer
the same for each event $j$ crossing a water level $i$, we will
replace the unweighted averaging operator $\vec{M}_u$ by the
inverse-variance-weighted-mean operator $\vec{M}$.  The
inverse-variance-weighted mean dynamic storage at water level $i$ is
computed as
\begin{equation}
  \label{eq:inverse_variance_weighted_mean_storage}
  \frac{\sum_{j\in J_i} (f_{ij} \tilde{r}_j + s_j) \sigma^{-2}_{ij}}
       {\sum_{j\in J_i} \sigma^{-2}_{ij}}
\end{equation}
where $\sigma^2_{ij} = \text{var}(f_{ij} \tilde{r}_j + s_j)$. Because
errors in observed recharge $\tilde{r}_j$ and storage $s_j$ are
uncorrelated,
\begin{equation}
  \sigma^2_{ij} = \text{var}(\alpha_j f_{ij} \tilde{r}_j) + \text{var}(s_j) = f_{ij}^2 r_j^2\sigma_\alpha^2 + \sigma_e^2.
\end{equation}
By (\ref{eq:inverse_variance_weighted_mean_storage}), the weighted
mean operator is given by
\begin{equation}
  \label{eq:weighted_mean_operator}
  \vec{M} = \left[
    \begin{array}{ccc}
      \frac{\sigma^{-2}_{i_1 j_1}}{\sum_{j\in J_{i_1}}\sigma^{-2}_{i_1 j}} [j_1\in J_{i_1}] & \cdots & \frac{\sigma^{-2}_{i_1 j_K}}{\sum_{j\in J_{i_1}}\sigma^{-2}_{i_1 j}} [j_K \in J_{i_1}] \\
      \vdots & \ddots & \vdots \\
      \frac{\sigma^{-2}_{i_K j_1}}{\sum_{j\in J_{i_K}}\sigma^{-2}_{i_K j}}[j_1 \in J_{i_K}] & \cdots & \frac{\sigma^{-2}_{i_K j_K}}{\sum_{j\in J_{i_K}}\sigma^{-2}_{i_K j}}[j_K \in J_{i_K}]
    \end{array}
  \right]
\end{equation}

Substituting the weighted mean operator $\vec{M}$
(\ref{eq:weighted_mean_operator}) and the expression for the recharge
with observation error $\tilde{\vec{r}}$
(\ref{eq:recharge_with_error}) into the unweighted system of equations
(\ref{eq:unweighted_equations_rearranged}) yields
\begin{equation}
  \left(\vec{I} - \vec{M}\right)\vec{FD}\,\left(\tilde{\vec{r}} - \text{diag}(\vec{r})\left(\bm\alpha - \vec{1}\right)\right) = -\left(\vec{I} - \vec{M}\right)\vec{DT}\,\vec{s} + \vec{e}
\end{equation}
Because of the multiplicative errors $\bm\alpha$ in recharge, we now
have an additional error term on the left-hand-side.  To express our
problem in the general form for a linear estimation problem
(\ref{eq:linear_estimation_problem}), we will absorb the recharge
errors into the error term $\vec{B}\vec{v}$.

Accordingly, we define a submatrix
\begin{equation}
  \label{eq:B_2}
  \vec{B}_2 = \sigma_\alpha\left(\vec{I} - \vec{M}\right)\vec{FD}\,\text{diag}(\vec{r})
\end{equation}
and a subvector $\vec{v}_2$ for the recharge errors, normalized to
zero mean and unit variance
\begin{equation}
  \label{eq:v_2}
  \vec{v}_2 = \frac{\bm\alpha - \vec{1}}{\sigma_\alpha}
\end{equation}
so that we can write
\begin{equation}
  \label{eq:weighted_mess}
  \left(\vec{I} - \vec{M}\right)\vec{FD}\,\tilde{\vec{r}} = -\left(\vec{I} - \vec{M}\right)\vec{DT}\,\vec{s} + \vec{e} + \vec{B}_2\vec{v}_2
\end{equation}
Then, defining a second submatrix $\vec{B}_1 = \sigma_e\vec{I}$ and
subvector $\vec{v}_1 = \vec{e} / \sigma_e$ to deal with the
uncorrelated errors, we combine these in a block matrix
$\vec{B} = \left[ \vec{B}_1 \vec{B}_2\right]$ and a block vector
\begin{equation}
  \label{eq:v_block}
  \vec{v} = \left[
    \begin{array}{c}
      \vec{v}_1\\
      \vec{v}_2
    \end{array}
  \right].
\end{equation}
Finally, after defining
$\vec{y} = \left(\vec{I} - \vec{M}\right)\vec{FD}\tilde{\vec{r}}$ and
$\vec{A} = -\left(\vec{I} - \vec{M}\right)\vec{DT}$ and substituting into
(\ref{eq:weighted_mess}), we arrive back at the general form for a linear estimation
problem (\ref{eq:linear_estimation_problem}).

The resulting weighted linear estimation problem can again be solved
by the typical approach to generalized least squares (\ref{eq:gls})
because its error covariance matrix
$\bm\Omega = \vec{B}\vec{B}^\mathsf{T}$ is invertible.  Expanding,
$\vec{B}\vec{B}^\mathsf{T} = \vec{B}_1\vec{B}_1^\mathsf{T} +
\vec{B}_2\vec{B}_2^\mathsf{T} = \sigma_e^2\vec{I} +
\vec{B}_2\vec{B}_2^\mathsf{T}$.  The addition of a positive multiple of
the identity matrix $\sigma_e^2\vec{I}$ to the symmetric positive
semidefinite matrix $\vec{B}_2\vec{B}_2^\mathsf{T}$ results in a
symmetric positive definite, and therefore invertible, covariance
matrix $\bm\Omega$.

So far we have ignored the fact that assembling the covariance matrix
factor $\vec{B}_2$ (\ref{eq:B_2}) requires the true recharge
$\vec{r}$, which we do not know.  Nonetheless, we initially have as an
estimate the imperfect observations $\tilde{\vec{r}}$, and by solving
the linear estimation problem (\ref{eq:linear_estimation_problem}) we
arrive at an estimate of the recharge errors $\bm\alpha$
(\ref{eq:v_2}), which we can use to improve our recharge estimates.
In practice, we found that repeatedly solving the weighted estimation
problem and updating the recharge $\tilde{\vec{r}}$ resulted in
convergence within a few iterations to a self-consistent solution for
storage offsets $\vec{s}$ and errors $\vec{v}$.

\begin{figure}[t!]
  \centerline{\includegraphics[scale=1]{build/doc/rise_event_test.pdf}}
  \caption{Effect of recharge error weighting in some simple test cases.}
  \label{fig:rise_event_test}
\end{figure}

\begin{figure}[t!]
  \centerline{\includegraphics[scale=1]{build/doc/multiplicative_error_test.pdf}}
  \caption{Effect of multiplicative vs.\ additive error in some simple
    test cases.}
  \label{fig:multiplicative_error_test}
\end{figure}


\end{document}
